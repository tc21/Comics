using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Serialization;
using Comics.Support;

namespace Comics {
    public class ComicLoadException : Exception {
        public ComicLoadException(string message) : base(message) { }
        public ComicLoadException() : base() { }
    }

    public class Comic : INotifyPropertyChanged {
        private static readonly Random randomizer = new Random();

        public readonly string real_title;
        public readonly string real_author;
        public readonly string real_category;
        public readonly string path;

        public static string CreateUniqueIdentifier(string real_author, string real_title)
            => $"[{real_author}]{real_title}";

        public string UniqueIdentifier => CreateUniqueIdentifier(this.real_author, this.real_title);

        /* If the thumbnail is contained within the work path, it will be stored as a relative path. */
        public string ThumbnailSource {
            get => this.Metadata.ThumbnailSource;
            set {
                if (!File.Exists(value)) {
                    return;
                }

                var info = new FileInfo(value);
                if (info.IsChildOf(this.path)) {
                    this.Metadata.ThumbnailSource = value.Substring(this.path.Length + 1);
                } else {
                    this.Metadata.ThumbnailSource = value;
                }

            }
        }

        public string AbsoluteThumbnailSource {
            get {
                if (this.ThumbnailSource == null) {
                    return null;
                }

                if (Path.IsPathRooted(this.ThumbnailSource)) {
                    return this.ThumbnailSource;
                }

                return Path.Combine(this.path, this.ThumbnailSource);
            }
        }

        // The thumbnail files are not to be generated by the Comic class itself (for performance reasons)
        public string ThumbnailPath => Path.Combine(Defaults.UserThumbnailsFolder, this.UniqueIdentifier + ".thumbnail.jpg");
        
        public IEnumerable<string> FilePaths => RetrieveFilesForComicAtPath(this.path);
        public int Random { get; set; }

        // For sorting only, for now
        public string DateAdded { get; set; }

        public Metadata Metadata { get; set; }

        public event PropertyChangedEventHandler PropertyChanged;
        private void NotifyPropertyChanged([CallerMemberName] string propertyName = "") {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public Comic(string title, string author, string category, string path, Metadata metadata = null, bool validate = true,
                     string dateAdded = "1970-01-01 00:00:00") {
            this.real_title = title;
            this.real_author = author;
            this.real_category = category;
            this.path = path;
            this.DateAdded = dateAdded;

            if (validate && !(Directory.Exists(path) || File.Exists(path))) {
                throw new ComicLoadException("Invalid path given to comic");
            }

            if (metadata is null) {
                metadata = SQL.Database.Manager.GetMetadata(this.UniqueIdentifier);
            }

            if (metadata is null) {
                metadata = new Metadata();
            }

            this.Metadata = metadata;

            this.Random = randomizer.Next();

            if (validate && !File.Exists(this.ThumbnailPath)) {
                this.ThumbnailSource = this.CreateThumbnailAndReturnLocation();
            }
        }

        // Not meant to replace HashCode()
        public int UniqueHashCode() {
            return this.real_title.GetHashCode() ^ this.real_author.GetHashCode() ^ this.real_category.GetHashCode() ^ this.path.GetHashCode();
        }

        private static IEnumerable<string> RetrieveFilesForComicAtPath(string path, int currentDepth = 0) {
            if (File.Exists(path)) {
                return new List<string> { path };
            }

            var di = new DirectoryInfo(path);
            return RetrieveFilesForComicAtPath(di, currentDepth);
        }

        private static IEnumerable<string> RetrieveFilesForComicAtPath(DirectoryInfo dir, int currentDepth = 0) {
            foreach (var file in ValidFilesForComicAtPath(dir, currentDepth)) {
                var suffix = Path.GetExtension(file.Name).ToLowerInvariant();
                if (Defaults.Profile.Extensions.Contains(suffix)) {
                    yield return file.FullName;
                }
            }
        }
        
        private static IEnumerable<FileInfo> ValidFilesForComicAtPath(DirectoryInfo dir, int currentDepth = 0) {
            var files = dir.GetFilesInNaturalOrder("*.*");
            foreach (var file in files) {
                yield return file;
            }

            currentDepth += 1;

            if (Defaults.Profile.SubdirectoryAction == Defaults.SubdirectoryAction.COMBINE
                    && Defaults.Profile.WorkTraversalDepth > currentDepth) {
                var dirs = dir.GetDirectoriesInNaturalOrder();
                foreach (var subdir in dirs) {
                    foreach (var file in ValidFilesForComicAtPath(subdir, currentDepth)) {
                        yield return file;
                    }
                }
            }
        }

        /* Creates a thumbnail for this comic and saves it to disk
         * Returns the *source* file from which the thumbnail was generated
         */
        public string CreateThumbnailAndReturnLocation() {
            if (File.Exists(this.path)) {
                if (this.AttemptGenerateThumbnailFromFile(this.path)) {
                    return this.path;
                }
                return null;
            }

            foreach (var file in ValidFilesForComicAtPath(new DirectoryInfo(this.path))) {
                if (this.AttemptGenerateThumbnailFromFile(file.FullName)) {
                    return file.FullName;
                }
            }

            return null;
        }

        public void GenerateThumbnail() {
            if (File.Exists(this.ThumbnailPath)) {
                File.Delete(this.ThumbnailPath);
            }

            this.AttemptGenerateThumbnailFromFile(this.AbsoluteThumbnailSource);
        }

        // returns whether a thumbnail was successfully generated from the file at path
        private bool AttemptGenerateThumbnailFromFile(string path) {
            if (path == null || !File.Exists(path)) {
                return false;
            }

            var width = Defaults.ThumbnailWidthForVisual();

            return (
                (File.Exists(path) && Thumbnails.CreateThumbnailFromImage(path, width, this.ThumbnailPath)) ||
                (Thumbnails.CanCreateThumbnailFromAudio(path) && Thumbnails.CreateThumbnailFromAudio(path, width, this.ThumbnailPath)) ||
                (Thumbnails.CanCreateThumbnailFromVideo(path) && Thumbnails.CreateThumbnailFromVideo(path, width, this.ThumbnailPath))
            );
        }

        // Public properties that update the UI when changed
        public string Title {
            get => this.Metadata.Title ?? this.real_title;
            set { this.Metadata.Title = value; this.Save(); this.NotifyPropertyChanged("Title"); }
        }

        public string Author {
            get => this.Metadata.Author ?? this.real_author;
            set { this.Metadata.Author = value; this.Save(); this.NotifyPropertyChanged("Author"); }
        }

        public string Category {
            get => this.real_category;
            set { }
        }

        public bool Loved {
            get => this.Metadata.Loved;
            set {
                this.Metadata.Loved = value;
                this.Save();
                this.NotifyPropertyChanged("Loved");
            }
        }

        public bool Disliked {
            get => this.Metadata.Disliked;
            set {
                this.Metadata.Disliked = value;
                this.Save();
                this.NotifyPropertyChanged("Disliked");
            }
        }

        // tags separated by commas
        public string TagString {
            get => (this.Metadata.Tags is null) ? "" : (string.Join(", ", this.Metadata.Tags) ?? "");
            set {
                this.Metadata.Tags = this.ParseTags(value);
                this.Save();
                this.NotifyPropertyChanged("Tags");
            }
        }

        private HashSet<string> ParseTags(string tags) {
            // non-empty tags split by commas
            return new HashSet<string>(tags.Split(',').Select((s) => s.ToLowerInvariant().Trim()).Where((s) => s != ""));
        }

        public HashSet<string> Tags => this.Metadata.Tags ?? new HashSet<string>();

        public void Open() {
            if (Defaults.Profile.DefaultApplication != null) {
                Defaults.Profile.DefaultApplication.StartComic(this);
            } else {
                Process.Start(this.FilePaths.First());
            }
        }

        public void OpenContainingFolder() {
            if (File.Exists(this.path)) {
                Process.Start(new FileInfo(this.path).DirectoryName);
            }

            Process.Start(this.path);
        }

        public static string TestExecutionString(string format) {
            return string.Join(" ", ExecutionString.CreateTestExecutionString(format));
        }

        public static class ExecutionString {
            // A special syntax for "opening" an item. The syntax defines 3 "special" characters:
            // { : used to start an expression; } : used to end an expression; \ : used to escape a special character
            // An expression uses the syntax {key:args}, where key and args are alphanumeric. 
            // "key" specifies what kind of argument, while "args" modify the way it is presented.
            private const string FirstFileKey = "first";
            private const string AllFilesKey = "all";
            private const string ContainingFolderKey = "folder";
            private const string FirstFilenameKey = "firstname";
            private const string AllFilenamesKey = "allname";
            private const string TitleKey = "title";
            private const string AuthorKey = "author";
            private const string CategoryKey = "category";

            public static IEnumerable<string> CreateExecutionArguments(string format, Comic comic) {

                if (string.IsNullOrEmpty(format)) {
                    return new List<string> { comic?.FilePaths.First() ?? "C:\\comic\\first.png" };
                }

                return Tokenize(format, comic);
            }
            
            private static IEnumerable<string> Tokenize(string format, Comic comic) {
                // Custom parsing
                var token = new List<char>();
                foreach (var c in format) {
                    if (token.Count == 0) {
                        if (!char.IsWhiteSpace(c)) {
                            token.Add(c);
                        }
                    } else {
                        if (token[token.Count - 1] == '\\') {
                            token[token.Count - 1] = Unescape(c);
                        } else if (token[0] == '{') {
                            if (c == '{') {
                                throw new TokenFormatException("Nested token (nested '{')");
                            } else if (c == '}') {
                                token.Add(c);
                                var match = Regex.Match(new string(token.ToArray()), "{([^:}]*)(:)?([^}]*)?}");
                                foreach (var str in ProcessToken(comic, match.Groups[1].Value, match.Groups[2].Success, match.Groups[3].Value)) {
                                    yield return str;
                                }
                                token.Clear();
                            } else {
                                token.Add(c);
                            }
                        } else {
                            if (char.IsWhiteSpace(c)) {
                                yield return new string(token.ToArray());
                                token.Clear();
                            } else {
                                token.Add(c);
                            }
                        }
                    }
                }
                if (token.Count > 0) {
                    if (token[0] == '{') {
                        throw new TokenFormatException("Unfinished token (unmatched '{')");
                    }
                    yield return new string(token.ToArray());
                }
            }

            public static IEnumerable<string> CreateTestExecutionString(string format) {
                return CreateExecutionArguments(format, null);
            }

            private static char Unescape(char token) {
                switch (token) {
                    case '\\':
                    case '{':
                    case '}':
                    case ' ':
                        return token;
                    default:
                        throw new TokenFormatException("Invalid escape sequence: \\" + token);
                }
            }

            private static readonly List<string> testfiles = new List<string>
            {
                "C:\\comic\\first.png",
                "C:\\comic\\second.png",
                "C:\\comic\\last.png"
            };

            public class TokenFormatException : Exception {
                public TokenFormatException(string message) : base(message) { }
            }

            // pass in a null comic for a test result
            private static IEnumerable<string> ProcessToken(Comic comic, string key, bool argsGiven, string args) {
                var files = comic?.FilePaths ?? testfiles;

                switch (key) {
                    case FirstFileKey:
                        yield return files.First();
                        yield break;
                    case AllFilesKey: {
                            if (!argsGiven || string.IsNullOrEmpty(args)) {
                                foreach (var f in files) {
                                    yield return f;
                                }
                                yield break;
                            } else {
                                yield return string.Join(args, files);
                                yield break;
                            }
                        }
                    case ContainingFolderKey:
                        yield return comic?.path ?? "C:\\comic";
                        yield break;
                    case FirstFilenameKey:
                        yield return Path.GetFileName(files.First());
                        yield break;
                    case AllFilenamesKey: {
                            var filenames = files.Select(p => Path.GetFileName(p));
                            if (!argsGiven || string.IsNullOrEmpty(args)) {
                                foreach (var fn in filenames) {
                                    yield return fn;
                                }
                                yield break;
                            } else {
                                yield return string.Join(args, filenames);
                                yield break;
                            }
                        }
                    case TitleKey:
                        yield return comic?.Title ?? "TITLE";
                        yield break;
                    case AuthorKey:
                        yield return comic?.Author ?? "AUTHOR";
                        yield break;
                    case CategoryKey:
                        yield return comic?.Category ?? "CATEGORY";
                        yield break;
                    default:
                        throw new TokenFormatException("Invalid key: " + key);
                }
            }
        }

        public bool MatchesSearchText(string searchText) {
            if (string.IsNullOrWhiteSpace(searchText)) {
                return true;
            }

            searchText = searchText.ToLowerInvariant();
            return this.Title.ToLowerInvariant().Contains(searchText) ||
                this.Author.ToLowerInvariant().Contains(searchText);
        }

        public bool MatchesCategories(ISet<string> categories) {
            return categories.Count == 0 || categories.Contains(this.Category);
        }

        public bool MatchesAuthors(ISet<string> authors) {
            return authors.Count == 0 || authors.Contains(this.Author);
        }

        public bool MatchesTags(ISet<string> tags) {
            return tags.Count == 0 || tags.Intersect(this.Tags).Count() > 0;
        }

        public class SortPropertyInfo {
            public string DisplayName { get; set; }
            public string Name { get; set; }
            public ListSortDirection ListSortDirection { get; set; }
        }


        public static readonly List<SortPropertyInfo> SortProperties = new List<SortPropertyInfo>() {
            new SortPropertyInfo { DisplayName = "Author", Name = "Author", ListSortDirection = ListSortDirection.Ascending },
            new SortPropertyInfo { DisplayName = "Title", Name = "Title", ListSortDirection = ListSortDirection.Ascending },
            new SortPropertyInfo { DisplayName = "Category", Name = "Category", ListSortDirection = ListSortDirection.Ascending },
            new SortPropertyInfo { DisplayName = "Date Added", Name = "DateAdded", ListSortDirection = ListSortDirection.Descending },
            new SortPropertyInfo { DisplayName = "Random", Name = "Random", ListSortDirection = ListSortDirection.Ascending },
        };

        public static readonly IEnumerable<string> SortPropertyNames = SortProperties.Select((property) => property.DisplayName);

        public static readonly int DefaultSortIndex = 0;
        public static readonly int RandomSortIndex = 3;
        public static List<SortPropertyInfo> SortDescriptionPropertiesForIndex(int index) {
            var sortPropertyNames = new List<SortPropertyInfo>(SortProperties);
            if (index > 0 && index < sortPropertyNames.Count) {
                var preferredProperty = sortPropertyNames[index];
                sortPropertyNames.RemoveAt(index);
                sortPropertyNames.Insert(0, preferredProperty);
            }
            return sortPropertyNames;
        }

        public void Save() {
            SQL.Database.Manager.UpdateComic(this);
        }
    }

    public class Metadata {
        // display title may be different from generated titles from path
        public string Title { get; set; }
        public string Author { get; set; }
        public string Category { get; set; }
        public HashSet<string> Tags { get; set; }
        public bool Loved { get; set; }
        public bool Disliked { get; set; }
        public string ThumbnailSource { get; set; }
    }
}
