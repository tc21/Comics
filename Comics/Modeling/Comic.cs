using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Serialization;

namespace Comics
{
    public class Comic : INotifyPropertyChanged
    {
        private readonly string title;
        private readonly string author;
        private readonly string category;
        private readonly string path;
        private string imagePath = null;
        private List<string> filePaths = new List<string>();

        public string UniqueIdentifier { get { return "[" + author + "]" + title; } }
        public string ImagePath { get { return Metadata.ThumbnailSource ?? imagePath; } }
        // The thumbnail and metadata files are not to be generated by the Comic class itself (for performance reasons)
        public string ThumbnailPath { get { return Path.Combine(Defaults.UserThumbnailsFolder, UniqueIdentifier + ".jpgthumbnail"); } }
        public string MetadataPath { get { return Path.Combine(Defaults.UserMetadataFolder, UniqueIdentifier + ".xmlmetadata"); } }
        public string ContainingPath { get { return path; } }
        public List<string> FilePaths { get { return filePaths; } }

        public int Random { get; set; }

        public Metadata Metadata { get; set; }

        public event PropertyChangedEventHandler PropertyChanged;
        private void NotifyPropertyChanged([CallerMemberName] String propertyName = "")
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public Comic(string title, string author, string category, string path)
        {
            this.title = title;
            this.author = author;
            this.category = category;
            this.path = path;

            if (Directory.Exists(path))
                AddDirectory(new DirectoryInfo(path));
            else if (File.Exists(path))
                filePaths.Add(path);
            else
                throw new Exception("Invalid path given to comic");

            if (!LoadMetadata())
                Metadata = new Metadata();
        }

        public void AddDirectory(DirectoryInfo directory)
        {
            FileInfo[] files = directory.GetFiles("*.*");

            foreach (FileInfo file in files)
            {
                string suffix = Path.GetExtension(file.Name).ToLowerInvariant();
                if (Defaults.Profile.Extensions.Contains(suffix))
                    filePaths.Add(file.FullName);
                if (imagePath == null && Defaults.ImageExtensions.Contains(suffix))
                    imagePath = file.FullName;
            }
        }

        // Creates a thumbnail for this comic and saves it to disk
        public void CreateThumbnail()
        {
            int width = Defaults.ThumbnailWidthForVisual();
            if (File.Exists(ImagePath) &&
                Thumbnails.CreateThumbnailFromImage(ImagePath, width, ThumbnailPath)) { }
            else if (Thumbnails.CanCreateThumbnailFromAudio(ImagePath) &&
                Thumbnails.CreateThumbnailFromAudio(ImagePath, width, ThumbnailPath)) { }
            else if (Thumbnails.CanCreateThumbnailFromVideo(ImagePath) &&
                Thumbnails.CreateThumbnailFromVideo(ImagePath, width, ThumbnailPath)) { }
            else if (Thumbnails.CanCreateThumbnailFromAudio(FilePaths.First()) &&
                Thumbnails.CreateThumbnailFromAudio(FilePaths.First(), width, ThumbnailPath)) { }
            else if (Thumbnails.CanCreateThumbnailFromVideo(FilePaths.First()) &&
                Thumbnails.CreateThumbnailFromVideo(FilePaths.First(), width, ThumbnailPath)) { }
            else
                return;
            NotifyPropertyChanged("ThumbnailPath");
        }

        // Public properties that update the UI when changed
        public SortedString Title
        {
            get { return Metadata.Title ?? new SortedString(title); }
            set { Metadata.Title = value; SaveMetadata(); NotifyPropertyChanged("Title"); }
        }

        public SortedString Author
        {
            get { return Metadata.Author ?? new SortedString(author); }
            set { Metadata.Author = value; SaveMetadata(); NotifyPropertyChanged("Author"); }
        }

        public SortedString Category
        {
            get { return Metadata.Category ?? new SortedString(category); }
            set { Metadata.Category = value; SaveMetadata(); NotifyPropertyChanged("Category"); }
        }

        public bool Loved
        {
            get { return Metadata.Loved; }
            set { Metadata.Loved = value; SaveMetadata(); NotifyPropertyChanged("Loved"); }
        }

        public bool Disliked
        {
            get { return Metadata.Disliked; }
            set { Metadata.Disliked = value; SaveMetadata(); NotifyPropertyChanged("Disliked"); }
        }
        
        // Maybe I will eventually code a viewer into this program, but I already have an image viewer.
        public void Open()
        {
            if (String.IsNullOrEmpty(Defaults.Profile.ExecutionString))
                Process.Start(filePaths.First());
            else
                Process.Start(ExecutionString.CreateExecutionString(Defaults.Profile.ExecutionString, this));
        }

        public void OpenContainingFolder()
        {
            Process.Start(path);
        }

        static class ExecutionString
        {
            // A special syntax for "opening" an item. The syntax defines 3 "special" characters:
            // { : used to start an expression; } : used to end an expression; \ : used to escape a special character
            // An expression uses the syntax {key:args}, where key and args are alphanumeric. 
            // "key" specifies what kind of argument, while "args" modify the way it is presented.
            private const string FirstFileKey = "first";
            private const string AllFilesKey = "all";
            private const string ContainingFolderKey = "folder";
            private const string FirstFilenameKey = "firstname";
            private const string AllFilenamesKey = "allname";
            private const string TitleKey = "title";
            private const string AuthorKey = "author";
            private const string CategoryKey = "category";
            
            public static string CreateExecutionString(string format, Comic comic)
            {
                if (String.IsNullOrEmpty(format))
                    return comic.FilePaths.First();
                string parsed = Regex.Replace(format, "\\\\(.)", m => UnescapeToken(m.Groups[1].Value));
                return Regex.Replace(format, "{(\\w*)(:)?(.*)?}", m => ProcessToken(comic, m.Groups[1].Value, m.Groups[2].Success, m.Groups[3].Value));
            }

            private static string UnescapeToken(string token)
            {
                switch (token)
                {
                    case "\\":
                    case "{":
                    case "}":
                        return token;
                    default:
                        throw new Exception("Invalid escape sequence: \\" + token);
                }
            }

            private static string ProcessToken(Comic comic, string key, bool argsGiven, string args)
            {
                switch (key)
                {
                    case FirstFileKey:
                        return comic.FilePaths.First();
                    case AllFilesKey:
                        {
                            string separator = argsGiven ? args : " ";
                            return String.Join(separator, comic.FilePaths);
                        }
                    case ContainingFolderKey:
                        return comic.ContainingPath;
                    case FirstFilenameKey:
                        return Path.GetFileName(comic.FilePaths.First());
                    case AllFilenamesKey:
                        {
                            string separator = argsGiven ? args : " ";
                            return String.Join(separator, comic.FilePaths.Select(p => Path.GetFileName(p)));
                        }
                    case TitleKey:
                        return comic.Title.Display;
                    case AuthorKey:
                        return comic.Author.Display;
                    case CategoryKey:
                        return comic.Category.Display;
                    default:
                        throw new Exception("Invalid key: " + key);
                }
            }
        }



        public bool MatchesSearchText(string searchText)
        {
            if (String.IsNullOrWhiteSpace(searchText))
                return true;

            searchText = searchText.ToLowerInvariant();
            return Title.Display.ToLowerInvariant().Contains(searchText) ||
                Title.Sort.ToLowerInvariant().Contains(searchText) ||
                Author.Display.ToLowerInvariant().Contains(searchText) ||
                Author.Sort.ToLowerInvariant().Contains(searchText);
        }

        public bool MatchesCategories(ISet<string> categories)
        {
            return categories.Count == 0 || categories.Contains(Category.Display);
        }

        public bool MatchesAuthors(ISet<string> authors)
        {
            return authors.Count == 0 || authors.Contains(Author.Display);
        }
        
        public static readonly List<string> SortPropertyNames = new List<string> { "Author", "Title", "Category", "Random" };
        public static readonly int RandomSortIndex = 3;
        public static List<string> SortDescriptionPropertyNamesForIndex(int index)
        {
            List<string> sortPropertyNames = new List<string>(SortPropertyNames);
            if (index > 0 && index < sortPropertyNames.Count)
            {
                string preferredProperty = sortPropertyNames[index];
                sortPropertyNames.RemoveAt(index);
                sortPropertyNames.Insert(0, preferredProperty);
            }
            return sortPropertyNames;
        }

        public void SaveMetadata()
        {
            XmlSerializer writer = new XmlSerializer(typeof(Metadata));
            string path = Path.Combine(Defaults.UserMetadataFolder, MetadataPath);
            string tempPath = path + ".tmp";

            using (FileStream tempFile = File.Create(tempPath))
                writer.Serialize(tempFile, Metadata);

            if (File.Exists(path))
                File.Delete(path);

            File.Move(tempPath, path);
        }

        public bool LoadMetadata()
        {
            Metadata profile;
            XmlSerializer reader = new XmlSerializer(typeof(Metadata));
            string path = Path.Combine(Defaults.UserMetadataFolder, MetadataPath);

            if (!File.Exists(path))
                return false;

            using (StreamReader file = new StreamReader(path))
                profile = (Metadata)reader.Deserialize(file);

            Metadata = profile;
            return true;
        }
    }

    public class Metadata
    {
        public SortedString Title { get; set; }
        public SortedString Author { get; set; }
        public SortedString Category { get; set; }
        public bool Loved { get; set; }
        public bool Disliked { get; set; }
        public string ThumbnailSource { get; set; }
    }

    public class SortedString : IComparable {
        public string Display { get; set; }
        public string Sort { get; set; }

        public SortedString() { }

        public SortedString(string display, string sort)
        {
            Display = display;
            Sort = sort;
        }

        public SortedString(string display) : this(display, display) { }

        public override string ToString()
        {
            return Display.ToString();
        }

        public override bool Equals(object obj)
        {
            if (obj is SortedString)
                return Sort.Equals(((SortedString)obj).Sort);

            return Sort.Equals(obj);
        }

        public override int GetHashCode()
        {
            return Sort.GetHashCode();
        }

        public int CompareTo(object other)
        {
            if (other is SortedString)
                return Sort.CompareTo(((SortedString)other).Sort);

            return Sort.CompareTo(other);
        }
    }
}
